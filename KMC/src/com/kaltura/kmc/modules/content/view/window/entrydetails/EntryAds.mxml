<?xml version="1.0" encoding="utf-8"?>
<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml" width="100%" height="100%"
		 implements="com.kaltura.kmc.modules.content.business.IDrilldownPanel" 
		 xmlns:controls="com.kaltura.controls.*">
	<mx:Metadata>
		[Event(name="cuepointsSaved", type="flash.events.Event")]
	</mx:Metadata>
	<mx:Script>
		<![CDATA[
			import com.kaltura.events.KClipErrorCodes;
			import com.kaltura.events.KClipEventTypes;
			import com.kaltura.events.KdpEventTypes;
			import com.kaltura.kmc.modules.content.events.CuePointEvent;
			import com.kaltura.kmc.modules.content.model.Context;
			import com.kaltura.kmc.modules.content.model.EntryDetailsModel;
			import com.kaltura.kmc.modules.content.vo.EntryDetailsValidationError;
			import com.kaltura.types.KalturaAdProtocolType;
			import com.kaltura.types.KalturaAdType;
			import com.kaltura.types.KalturaCuePointType;
			import com.kaltura.types.KalturaEntryStatus;
			import com.kaltura.utils.ObjectUtil;
			import com.kaltura.vo.KalturaAdCuePoint;
			import com.kaltura.vo.KalturaBaseEntry;
			import com.kaltura.vo.KalturaMediaEntry;
			
			import mx.binding.utils.BindingUtils;
			import mx.binding.utils.ChangeWatcher;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.SWFLoader;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			import mx.resources.ResourceManager;

			
			private static const BULK_ACTIONS:Array = [{label: ResourceManager.getInstance().getString('cms', 'ads_bulk_upload'), value: 'ads_bulk_upload'},
				{label: ResourceManager.getInstance().getString('cms', 'ads_bulk_download'), value: 'ads_bulk_download'},
				{label: ResourceManager.getInstance().getString('cms', 'ads_bulk_sample'), value: 'ads_bulk_sample'}];

			private static const AD_TYPES:Array = [{label: ResourceManager.getInstance().getString('cms', 'type_midroll'), value: KalturaAdType.VIDEO},
				{label: ResourceManager.getInstance().getString('cms', 'type_overlay'), value: KalturaAdType.OVERLAY}];

			private static const PROVIDERS:Array = [{label: ResourceManager.getInstance().getString('cms', 'provider_vast'), value: 'vast'},
				{label: ResourceManager.getInstance().getString('cms', 'provider_freewheel'), value: 'freewheel'},
				{label: ResourceManager.getInstance().getString('cms', 'provider_other'), value: 'other'}];

			private const LABEL_WIDTH:int = 80;
			
			public static const XML_EXL:String = "*.xml";

			/**
			 * clipper ruler is kept between different
			 * instances of the window as optimisation
			 * */
			private var _kClip:DisplayObject;
			private static var kClipLoader:SWFLoader;
			
			/**
			 * a flag used to determine we can talk with the kClip
			 * */
			private static var kClipReady:Boolean = false; 

			/**
			 * player is kept between different
			 * instances of the window as optimisation
			 * */
			private var _kdp:DisplayObject;
			private static var kdpLoader:SWFLoader;

			[Bindable]
			/**
			 * should components in the tab be editable
			 * */
			public var editable:Boolean = true;

			public var context:Context;


			public var entryDetailsModel:EntryDetailsModel;

			[Bindable]
			/**
			 * number of currently present cuepoints on kClip
			 * */
			private var _counter:int = 0;

			[Bindable]
			/**
			 * @copy @selectedEntry
			 * */
			private var _selectedEntry:KalturaBaseEntry;

			[Bindable]
			/**
			 * is the cuepoints details form enabled
			 * */
			private var _formEnabled:Boolean = false;

			[Bindable]
			/**
			 * the cuepoint currently being edited
			 * */
			private var _selectedCuePoint:KalturaAdCuePoint/*  = new KalturaAdCuePoint() */;

			/**
			 * change watcher for reacting to cueopints count being set on model
			 * */
			private var _watchCPCount:ChangeWatcher;

			/**
			 * image for KDP when entry is in no_content status
			 * */
			private var _img:Image;
			
			private var _bulkUpldFileRef:FileReference;
			

			public function get reloadCuePoints():Boolean
			{
				return false;
			}

			/**
			 * reload cue points if true
			 * */
			public function set reloadCuePoints(value:Boolean):void
			{
				if (value &&_kClip) {
					// reload cue points
					_kClip["loadCuePoints"]();
				}
			}

			public function destroy():void {
				if (_kdp) {
					_kdp.removeEventListener(KdpEventTypes.PLAYER_UPDATE_PLAYHEAD, handleKdpEvents, false);
					_kdp.removeEventListener(KdpEventTypes.PLAYER_PLAYED, handleKdpEvents, false);
					_kdp.removeEventListener(KdpEventTypes.PLAYER_PAUSED, handleKdpEvents, false);
					_kdp.removeEventListener(KdpEventTypes.PLAYER_PLAY_END, handleKdpEvents, false);
					_kdp["sendNotification"](KdpEventTypes.DO_STOP);
				}
				if (_kClip) {
					removeKClipListeners();
				}
				if (_watchCPCount) {
					_watchCPCount.unwatch();
				}
			}


			public function initData():void {
				// reset number of cuepoints
				var cg:CuePointEvent = new CuePointEvent(CuePointEvent.RESET_CUEPOINTS_COUNT);
				cg.dispatch();
				if (!_watchCPCount) {
					_watchCPCount = BindingUtils.bindSetter(adjustBulkActions, entryDetailsModel, "cuepointsCount");
				}
				loadWidgets(null);
				// get number of entry cuepoints
				cg = new CuePointEvent(CuePointEvent.COUNT_CUEPOINTS);
				cg.data = _selectedEntry.id;
				cg.dispatch();
			}


			/**
			 * triggers save action for cuepoints if needed.
			 * @return true if save process required (and began), false otherwise
			 * */
			public function saveCuepoints():Boolean {
				var res:Boolean = false;
				if (_kClip && kClipReady) {
					if (_kClip["isSavedRequired"]()) {
						_kClip.addEventListener(KClipEventTypes.SAVED, handleKClipEvents);
						_kClip["save"]();
						res = true;
					}
				}
				// if the component wasn't ready data couldn't change, therefore save isn't required.
				return res;
			}


			public function get selectedEntry():KalturaBaseEntry {
				return _selectedEntry;
			}
			
			/**
			 * The entry being edited
			 * */
			public function set selectedEntry(value:KalturaBaseEntry):void {
				_selectedEntry = value;
//				updateWidgetsStatus();
			}


			private function updateWidgetsStatus(updateKClip:Boolean = true, updateKdp:Boolean = true, setEntryId:Boolean = true):void {
				if (_selectedEntry.status != KalturaEntryStatus.READY) {
					if (updateKClip && _kClip && kClipReady) {
						_kClip["setDisabled"](true);
					}
					if (updateKdp) {
						if (!_img) {
							_img = new Image();
						}
						_img.source = StyleManager.getStyleDeclaration(".imageBank").getStyle("noContentImg");
						if (!_img.parent) {
							kdpHolder.addChild(_img);
						}
						if (_kdp && kdpLoader.parent) {
							kdpHolder.removeChild(kdpLoader);
						}
					}
				} else {
					if (updateKClip && _kClip && setEntryId && kClipReady) {
						_kClip["setEntryId"](_selectedEntry.id);
					}
					if (updateKdp && _kdp) {
						if (!kdpLoader.parent) {
							kdpHolder.addChild(kdpLoader);
						}
						if (setEntryId) {
							_kdp["sendNotification"](KdpEventTypes.CHANGE_MEDIA, {entryId: _selectedEntry.id});
						}
					}
					if (updateKdp && _img && _img.parent) {
						kdpHolder.removeChild(_img);
					}
				}
			}

			
			/**
			 * trigger cuepoints validation
			 * @return validation result
			 * @internal
			 * in other entry details panels, this function also sets the values 
			 * from the view to the KalturaBaseEntry being edited. since cuepoint
			 * data is not saved on the entry itself, this part is irrelevant for
			 * this panel. the name is retained for consistency. 
			 * */
			public function save():EntryDetailsValidationError {
				var result:EntryDetailsValidationError = new EntryDetailsValidationError();
				if (!validate()) {
					//failed validation
					result.error = EntryDetailsValidationError.CUEPOINTS_DATA;
				}
				return result;
			}



			/**
			 * adjust the dataprovider for file actions dropdown
			 * @param cuepoints count
			 * */
			private function adjustBulkActions(value:Object):void {
				// copy the array for the new entry
				var ar:Array = BULK_ACTIONS.concat();
				
				if (value != null && value == 0) {
					// remove the download option
					ar.splice(1, 1);
				}
				if (!editable) {
					// remove the upload action
					ar.splice(0, 1);
				}
				cbActions.dropdown.dataProvider = ar;
				cbActions.dataProvider = ar;
				cbActions.selectedIndex = -1; 
				cbActions.enabled = true;
			}


			/**
			 * set the given CP's values in the details form.
			 * */
			private function editCuePoint(o:Object):void {
				var cp:KalturaAdCuePoint = new KalturaAdCuePoint();
				ObjectUtil.copyObject(o, cp);
				_selectedCuePoint = cp;
//				if (cp) {
					// if roles and permissions allow editing, make the form editable
					if (editable) {
						_formEnabled = true;
					}
					cbType.selectedIndex = getAdType(_selectedCuePoint);
					cbProvider.selectedItem = getAdProvider(_selectedCuePoint);
//				} else {
//					_formEnabled = false;
//				}
			}


			/**
			 * load KDP and KClip or add them to stage, as needed.
			 * */
			private function loadWidgets(event:FlexEvent):void {
				if (EntryAds.kClipLoader) {
					kClipHolder.addChild(kClipLoader);
					_kClip = kClipLoader.content["application"] as DisplayObject;
					_kClip.width = kClipHolder.width;
					addKClipListeners();
					if (_selectedEntry) {
						updateWidgetsStatus(true, false);
					}
				} else {
					var url:String = "http://" + context.rootUrl + "/kgeneric/ui_conf_id/" + context.kClipAdsUiconf;
					EntryAds.kClipLoader = new SWFLoader();
					kClipHolder.addChild(kClipLoader);
					kClipLoader.addEventListener(Event.COMPLETE, onKClipLoaded);
					kClipLoader.scaleContent = true;
					kClipLoader.loaderContext = new LoaderContext(false, new ApplicationDomain(), SecurityDomain.currentDomain);
					kClipLoader.load(url);
				}

				if (EntryAds.kdpLoader) {
					kdpHolder.addChild(kdpLoader);
					_kdp = kdpLoader.content;
					if (_selectedEntry) {
						updateWidgetsStatus(false, true);
					}
				} else {
					var newUrl:String = "http://" + context.rootUrl + "/kwidget/wid/_" + context.kc.partnerId + "/ui_conf_id/" + context.drilldownUiconf + "/nowrapper/1";
					EntryAds.kdpLoader = new SWFLoader();
					kdpLoader.addEventListener(Event.COMPLETE, onKdpLoaded);
					kdpLoader.scaleContent = false;
					kdpLoader.loaderContext = new LoaderContext(true, new ApplicationDomain());
					kdpLoader.load(newUrl);
				}

			}


			/**
			 * wait for kClip application to be ready
			 * */
			private function onKClipLoaded(e:Event):void {
				kClipLoader.removeEventListener(Event.COMPLETE, onKClipLoaded);
				kClipLoader.width = kClipHolder.width;
				kClipLoader.height = kClipHolder.height;
				kClipLoader.content.addEventListener(FlexEvent.APPLICATION_COMPLETE, onKClipApplicationReady);
			}


			private function onKClipApplicationReady(e:Event):void {
				// e.target is the systemManager for KClip
				e.target.removeEventListener(FlexEvent.APPLICATION_COMPLETE, onKClipApplicationReady);
				_kClip = e.target.application as DisplayObject;
				initKClip();
			}


			/**
			 * initialize kClip
			 * */
			private function initKClip():void {
				var params:Object = {};
				params.ks = context.kc.ks;
				params.host = context.rootUrl;
				params.state = "cuePointsState";
				params.showControlBar = "true";
				params.partner_id = context.kc.partnerId;
				params.uiconf_id = context.kClipAdsUiconf;
				params.cuepointType = KalturaCuePointType.AD;
				addKClipListeners();
				_kClip["init"](params);
				_kClip.width = kClipHolder.width;
			}


			private function addKClipListeners():void {
				_kClip.addEventListener(KClipEventTypes.PLAYHEAD_UPDATED, handleKClipEvents);
				_kClip.addEventListener(KClipEventTypes.SELECTED_ASSET_REMOVED, handleKClipEvents);
				_kClip.addEventListener(KClipEventTypes.ALL_ASSETS_REMOVED, handleKClipEvents);
				_kClip.addEventListener(KClipEventTypes.CUE_POINT_CHANGED, handleKClipEvents);
				_kClip.addEventListener(KClipEventTypes.SELECTED_ASSET_CHANGED, handleKClipEvents);
				_kClip.addEventListener(KClipEventTypes.ENTRY_READY, handleKClipEvents);
				_kClip.addEventListener(KClipEventTypes.CLIPPER_ERROR, handleKClipEvents);
				_kClip.addEventListener(KClipEventTypes.CUE_POINT_ADDED, handleKClipEvents);
				_kClip.addEventListener(KClipEventTypes.CLIPPER_READY, handleKClipEvents);
			}


			private function removeKClipListeners():void {
				_kClip.removeEventListener(KClipEventTypes.PLAYHEAD_UPDATED, handleKClipEvents);
				_kClip.removeEventListener(KClipEventTypes.SELECTED_ASSET_REMOVED, handleKClipEvents);
				_kClip.removeEventListener(KClipEventTypes.ALL_ASSETS_REMOVED, handleKClipEvents);
				_kClip.removeEventListener(KClipEventTypes.CUE_POINT_CHANGED, handleKClipEvents);
				_kClip.removeEventListener(KClipEventTypes.SELECTED_ASSET_CHANGED, handleKClipEvents);
				_kClip.removeEventListener(KClipEventTypes.ENTRY_READY, handleKClipEvents);
				_kClip.removeEventListener(KClipEventTypes.CLIPPER_ERROR, handleKClipEvents);
				_kClip.removeEventListener(KClipEventTypes.CUE_POINT_ADDED, handleKClipEvents);
				_kClip.removeEventListener(KClipEventTypes.CLIPPER_READY, handleKClipEvents);
			}


			/**
			 * handle all kClip events
			 * */
			private function handleKClipEvents(e:Event):void {
				switch (e.type) {
					case KClipEventTypes.CLIPPER_READY:
						kClipReady = true;
						// disable or set entry id
						if (_selectedEntry.status != KalturaEntryStatus.READY) {
							_kClip["setDisabled"](true);
						}
						else {
							_kClip["setEntryId"](_selectedEntry.id);
						}
						break;
					case KClipEventTypes.ENTRY_READY:
						_kClip["setDisabled"](!editable);
						break;
					case KClipEventTypes.PLAYHEAD_UPDATED:
						updateKdpPlayhead(parseFloat(e["data"]) / 1000);
						break;
					case KClipEventTypes.SELECTED_ASSET_REMOVED:
						_formEnabled = false;
						_counter--;
						if (_counter < 0) {
							_counter = 0;
							trace("removing more cuepoints than we have..");
						}
						break;
					case KClipEventTypes.ALL_ASSETS_REMOVED:
						_formEnabled = false;
						_counter = 0;
						break;
					case KClipEventTypes.CUE_POINT_CHANGED:
						editCuePoint(e["data"]);
						break;
					case KClipEventTypes.SELECTED_ASSET_CHANGED:
						editCuePoint(e["data"]);
						break;
					case KClipEventTypes.CLIPPER_ERROR:
						onKClipError(e["data"]);
						break;
					case KClipEventTypes.CUE_POINT_ADDED:
						_counter++;
						break;
					case KClipEventTypes.SAVED:
						dispatchEvent(new Event("cuepointsSaved"));
						break;
				}
			}


			/**
			 * show user the error.
			 * @internal
			 * error localization should be done in kClip, not KMC.
			 * */
			private function onKClipError(errorVo:Object):void {
				// errorVo.messageText, errorVo.messageCode
				//TODO KClipErrorCodes.CUEPOINT_LOCATION_FAILED - don't show error right away, wait for 
				// the panel to show and only then show.
				if (errorVo.messageCode != KClipErrorCodes.CUEPOINT_LOCATION_FAILED) {
					Alert.show(errorVo.messageText);
				}
			}



			private function onKdpLoaded(e:Event):void {
				var loader:SWFLoader = e.target as SWFLoader;
				loader.width = kdpHolder.width;
				loader.height = kdpHolder.height;
				_kdp = loader.content;
				updateWidgetsStatus(false, true, false);
				if (!kdpLoader.parent) {
					kdpHolder.addChild(kdpLoader);
				}
				if (_img && _img.parent) {
					kdpHolder.removeChild(_img);
				}

				initKdp();
			}


			/**
			 * initialize KDP
			 */
			private function initKdp():void {
				//set kdp params
				var params:Object = new Object();
				params.widgetId = "_" + context.kc.partnerId;
				params.cdnHost = context.cdnHost;
				params.host = context.rootUrl;
				params.autoPlay = "false";
				params.loop = "false";
				params.autoRewind = "false";
				params.sourceType = "entryId";
				params.entryId = _selectedEntry.id;
				if (context.drilldownUiconf)
					params.uiConfId = context.drilldownUiconf;
				params.ks = context.kc.ks;
				params.partnerId = context.kc.partnerId;
				params.subpId = context.kc.partnerId + "00";

				params.debugMode = context.debugMode;

				_kdp["flashvars"] = params;
				//start the loading sqeunce of the kdp	
				_kdp["init"]();
				_kdp.addEventListener(KdpEventTypes.PLAYER_PLAYED, handleKdpEvents, false, 0, true);
				_kdp.addEventListener(KdpEventTypes.PLAYER_PAUSED, handleKdpEvents, false, 0, true);
				_kdp.addEventListener(KdpEventTypes.PLAYER_PLAY_END, handleKdpEvents, false, 0, true);
			}


			private function handleKdpEvents(e:Event):void {
				switch (e.type) {
					case KdpEventTypes.PLAYER_PLAYED:
						_kdp.addEventListener(KdpEventTypes.PLAYER_UPDATE_PLAYHEAD, handleKdpEvents, false, 0, true);
						_kClip.removeEventListener(KClipEventTypes.PLAYHEAD_UPDATED, handleKClipEvents);
						break;
					case KdpEventTypes.PLAYER_PAUSED:
					case KdpEventTypes.PLAYER_PLAY_END:
						_kdp.removeEventListener(KdpEventTypes.PLAYER_UPDATE_PLAYHEAD, handleKdpEvents, false);
						_kClip.addEventListener(KClipEventTypes.PLAYHEAD_UPDATED, handleKClipEvents);
						break;
					case KdpEventTypes.PLAYER_UPDATE_PLAYHEAD:
						if (_kClip) {
							_kClip["scrollToPoint"](parseFloat(e["data"]) * 1000)
						}
						break;
				}
			}


			/**
			 * update kdp with new time (event data is new time in ms)
			 * */
			private function updateKdpPlayhead(n:Number):void {
				if (_kdp) {
					_kdp["sendNotification"](KdpEventTypes.DO_SEEK, n);
				}
			}


			private function updateCuePointData(e:Event):void {
				// timing
				_selectedCuePoint.startTime = teTiming.getTimeAsSeconds() * 1000;
				// name
				_selectedCuePoint.title = tiName.text;
				// provider
				var value:String = cbProvider.selectedItem.value;
				if (value == "vast") {
					_selectedCuePoint.protocolType = KalturaAdProtocolType.VAST;
					_selectedCuePoint.tags = '';
				}
				else if (value == "freewheel") {
					_selectedCuePoint.protocolType = KalturaAdProtocolType.CUSTOM;
					_selectedCuePoint.tags = value;
				}
				else {
					// "other" provider
					_selectedCuePoint.protocolType = KalturaAdProtocolType.CUSTOM;
					_selectedCuePoint.tags = tiProvider.text;
				}
				// source url
				_selectedCuePoint.sourceUrl = tiUrl.text;
				// ad type
				_selectedCuePoint.adType = (cbType.selectedItem) ? cbType.selectedItem.value : null;
				// duration
				_selectedCuePoint.endTime =  _selectedCuePoint.startTime + teDuration.getTimeAsSeconds() * 1000;
				// update
				_kClip["updateCuePoint"](_selectedCuePoint);
			}
			
			
			/**
			 * validate all the cuepoints on kClip
			 * @return false if at least one cuepoint is invalid, true otherwise.
			 * */
			private function validate():Boolean {
				if (!kClipReady) {
					// the component wasn't ready so no data 
					// could have changed to invalid data
					return true;
				}
				var ret:Boolean = true;
				var cpresult:Boolean;
				var cps:Array = getCuepoints();
				for each (var cp:KalturaAdCuePoint in cps) {
					cpresult = validateCuePoint(cp);
					// mark this cp as in/valid
					_kClip["setError"](!cpresult, cp.id);
					ret &&= cpresult;
				}
				return ret;
			}
			
			
			/**
			 * validate required fields of the given cuepoint
			 * @param cp	cuepoint to test
			 * @return true if validation passed, false otherwise.
			 * */
			private function validateCuePoint(cp:KalturaAdCuePoint):Boolean {
				// ad type
				if (cp.adType != KalturaAdType.VIDEO && cp.adType != KalturaAdType.OVERLAY) {
//					Alert.show(resourceManager.getString('cms', 'ads_invalid_ad_type'));
					return false;
				}  
				// duration
				if (cp.adType == KalturaAdType.OVERLAY) {
					if (cp.endTime < cp.startTime) {
//						Alert.show(resourceManager.getString('cms', 'ads_invalid_out_time'));
						return false;
					}
				}
				return true;
			}
			
			/**
			 * retreive a list of cuepoints from kClip.
			 * @return all cuepoints currently displayed on kClip.
			 * 
			 * @internal
			 * we have to translate kclip cps to kmc cps, because
			 * of the different ApplicationDomains.
			 * */
			private function getCuepoints():Array {
				var kclipcps:Array = _kClip["getAll"]();
				var cps:Array = new Array();
				var cp:KalturaAdCuePoint;
				for each (var o:Object in kclipcps) {
					cp = new KalturaAdCuePoint();
					ObjectUtil.copyObject(o, cp);
					cps.push(cp);
				}
				return cps;
			}

			
			
			/**
			 * calculate cuepoint duration
			 * */
			private function getDuration(acp:KalturaAdCuePoint):Object {
				if (acp.endTime) {
					return teDuration.getTimeAsObject(Math.floor((acp.endTime - acp.startTime)/1000));
				} else
					return teDuration.getTimeAsObject(4);
			}


			/**
			 * return the correct string to show in the ad provider text field,
			 * i.e. nothing for vast or freewheel, or the tags string for "other".
			 * */
			private function getAdProviderText(acp:KalturaAdCuePoint):String {
				if (!acp || acp.protocolType == KalturaAdProtocolType.VAST) {
					return '';
				} 
				else if (acp.protocolType == KalturaAdProtocolType.CUSTOM) {
					if (acp.tags == "freewheel") {
						return '';
					}
					else if (!acp.tags) {
						return resourceManager.getString('cms', 'ads_default_provider');
					}
					else {
						return acp.tags + "";
					}
				}
				return resourceManager.getString('cms', 'ads_default_provider');
			}


			/**
			 * get the object in PROVIDERS that represents the tags of the given CP
			 * @param cp
			 * */
			private function getAdProvider(cp:KalturaAdCuePoint):Object {
				var value:String = cbProvider.selectedItem.value;
				if (_selectedCuePoint.protocolType == KalturaAdProtocolType.VAST 
					&& _selectedCuePoint.tags == '') {
					value == "vast"
				}
				else if (_selectedCuePoint.protocolType == KalturaAdProtocolType.CUSTOM
					&& _selectedCuePoint.tags == "freewheel") {
					value = "freewheel";
				}
				else {
					value = "other";
				}
				
				for (var i:int = 0; i < PROVIDERS.length; i++) {
					if (PROVIDERS[i].value == value) {
						return PROVIDERS[i];
					}
				}
				// the last object is the "Other"
				return PROVIDERS[PROVIDERS.length - 1];
			}


			/**
			 * get the object in AD_TYPES that represents the adType of the given CP
			 * @param cp
			 * */
			private function getAdType(cp:KalturaAdCuePoint):int {
				for (var i:int = 0; i < AD_TYPES.length; i++) {
					if (AD_TYPES[i].value == cp.adType) {
						return i;
					}
				}
				return -1;
			}


			private function updateKClipWidth(event:FlexEvent):void {
				if (kClipLoader) {
					kClipLoader.width = kClipHolder.width - 1;
					if (_kClip) {
						_kClip.width = kClipLoader.width;
					}
				}
			}


			protected function removeAllCuePoints(event:MouseEvent):void {
				if (_kClip && kClipReady) {
					_kClip["removeAll"]();
				}
			}


			private function handleBulkActions(event:ListEvent):void {
				var action:String = (event.target as ComboBox).selectedItem.value;
				switch (action) {
					case 'ads_bulk_upload':
						_bulkUpldFileRef = new FileReference();
						_bulkUpldFileRef.addEventListener(Event.SELECT, addBulkUpload);
						_bulkUpldFileRef.browse(new Array(new FileFilter(resourceManager.getString('cms','files') +' (' + XML_EXL + ')' ,XML_EXL)));
						break;
					case 'ads_bulk_download':
						var cg:CuePointEvent = new CuePointEvent(CuePointEvent.DOWNLOAD_CUEPOINTS);
						cg.data = _selectedEntry.id;
						cg.dispatch();
						break;
					case 'ads_bulk_sample':
						// download samples file
						var req:URLRequest = new URLRequest(entryDetailsModel.cuepointsSamplesUrl);
						navigateToURL(req);
						break;
				}
				cbActions.selectedIndex = -1;
			}
			
			/**
			 * on buld file selected
			 * */
			private function addBulkUpload(event:Event):void {
				_bulkUpldFileRef.removeEventListener(Event.SELECT, addBulkUpload);
				var cg:CuePointEvent = new CuePointEvent(CuePointEvent.UPLOAD_CUEPOINTS);
				cg.data = _bulkUpldFileRef;
				cg.dispatch();
			}


			protected function cbActions_updateCompleteHandler(event:FlexEvent):void
			{
				if (cbActions.dropdown) {
					cbActions.dropdown.width = cbActions.width;
				}
			}

		]]>
	</mx:Script>

	<mx:HBox width="100%">
		<mx:VBox width="100%" height="{kdpHolder.height}">
			<mx:HBox width="100%">
				<mx:Spacer width="100%"/>
				<mx:ComboBox id="cbActions" width="100%" change="handleBulkActions(event)" updateComplete="cbActions_updateCompleteHandler(event)"
							 prompt="{resourceManager.getString('cms', 'ads_bulk_actions')}" enabled="false"/>
			</mx:HBox>
			<mx:Text htmlText="{resourceManager.getString('cms', 'ads_explain')}" width="100%"
					 visible="{!_formEnabled}" includeInLayout="{!_formEnabled}" />
			<mx:VBox id="details" width="100%" visible="{_formEnabled}" includeInLayout="{_formEnabled}">
				<mx:HBox styleName="noPadding">
					<mx:Label text="{resourceManager.getString('cms', 'timing')}" styleName="formLabel"
							  width="{LABEL_WIDTH}"/>
					<controls:TimeStepper id="teTiming" enabled="{_formEnabled}" 
										  maximum="{(_selectedEntry as KalturaMediaEntry).duration}"
										  timeValue="{teTiming.getTimeAsObject(_selectedCuePoint.startTime/1000)}"
										  showHours="{(_selectedEntry as KalturaMediaEntry).duration > 3600}" showSeconds="true" showMiliseconds="true" 
										  change="updateCuePointData(event)"/>
				</mx:HBox>
				<mx:HBox width="100%" styleName="noPadding">
					<mx:Label text="{resourceManager.getString('cms', 'ads_type')}" styleName="formLabel"
							  width="{LABEL_WIDTH}"/>
					<mx:ComboBox id="cbType" width="100%" enabled="{_formEnabled}" dataProvider="{AD_TYPES}"
								 prompt="{resourceManager.getString('cms', 'ads_ad_type')}"
								 change="updateCuePointData(event)"/>
					<controls:TimeStepper id="teDuration" enabled="{_formEnabled &amp;&amp; cbType.selectedIndex == 1}" 
										  showHours="{(_selectedEntry as KalturaMediaEntry).duration > 3600}" 
										  showMiliseconds="true" showSeconds="true" timeValue="{getDuration(_selectedCuePoint)}"
										  change="updateCuePointData(event)"/>
				</mx:HBox>
				<mx:HBox width="100%" styleName="noPadding">
					<mx:Label text="{resourceManager.getString('cms', 'ads_provider')}" styleName="formLabel"
							  width="{LABEL_WIDTH}"/>
					<mx:VBox width="100%" styleName="noPadding">
						<mx:ComboBox id="cbProvider" enabled="{_formEnabled}" dataProvider="{PROVIDERS}"
									 change="updateCuePointData(event)"/>
						<mx:TextInput id="tiProvider" width="100%" text="{getAdProviderText(_selectedCuePoint)}"
									  enabled="{cbProvider.selectedItem.value == 'other'}"
									  change="updateCuePointData(event)"/>
					</mx:VBox>
				</mx:HBox>
				<mx:HBox width="100%" styleName="noPadding">
					<mx:Label text="{resourceManager.getString('cms', 'ads_url')}" styleName="formLabel"
							  width="{LABEL_WIDTH}"/>
					<mx:VBox width="100%" styleName="noPadding">
						<mx:TextInput id="tiUrl" width="100%" text="{_selectedCuePoint.sourceUrl}" 
									  change="updateCuePointData(event)"/>
						<!-- fix tiUrl text to show default text -->
					</mx:VBox>
				</mx:HBox>
				<mx:HBox width="100%" styleName="noPadding">
					<mx:Label text="{resourceManager.getString('cms', 'ads_name')}" styleName="formLabel"
							  width="{LABEL_WIDTH}"/>
					<mx:TextInput id="tiName" width="100%" enabled="{_formEnabled}" text="{_selectedCuePoint.title}" 
								  change="updateCuePointData(event)"/>
				</mx:HBox>
			</mx:VBox>
		</mx:VBox>
		<mx:HBox id="kdpHolder" width="300" height="255" tabChildren="false" tabEnabled="false"/>
	</mx:HBox>
	<mx:HBox id="kClipHolder" width="100%" height="120" updateComplete="updateKClipWidth(event)"/>
	<mx:HBox width="100%">
		<mx:Spacer width="100%"/>
		<mx:LinkButton label="{resourceManager.getString('cms', 'ads_remove_all')}" click="removeAllCuePoints(event)"
					   visible="{_counter > 0 &amp;&amp; editable}"
					   includeInLayout="{_counter > 0  &amp;&amp; editable}"/>
	</mx:HBox>
</mx:VBox>
